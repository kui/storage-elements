{"version":3,"sources":["webpack:///webpack/bootstrap 1eb2941c24381fbca42c","webpack:///./src/storage-elements-registerer.js","webpack:///./src/area-handler.js","webpack:///./src/storage-form.js","webpack:///./src/utils.js"],"names":[],"mappings":"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","file":"storage-elements.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1eb2941c24381fbca42c","/* global chrome */\n\nimport StorageForm from \"./storage-form\";\nimport * as ah from \"./area-handler\";\n\n// Register area handlers\nif (localStorage)\n  ah.registerHandler(\"local-storage\", new ah.WebStorageAreaHandler(localStorage));\nif (sessionStorage)\n  ah.registerHandler(\"session-storage\", new ah.WebStorageAreaHandler(sessionStorage));\nif (chrome && chrome.storage) {\n  if (chrome.storage.local)\n    ah.registerHandler(\"chrome-local\", new ah.ChromeStorageAreaHandler(chrome.storage.local));\n  if (chrome.storage.sync)\n    ah.registerHandler(\"chrome-sync\", new ah.ChromeStorageAreaHandler(chrome.storage.sync));\n}\n\n// Custom Element v1 seems not to working right on Google Chrome 55\n// customElements.define(name, ce, { extends: ex });\n\n// Custom Element v0\n// $FlowFixMe Avoid to affect code of `storage-form.js` by Custom Element v0\nObject.defineProperty(StorageForm, \"extends\", { get: () => \"form\" });\ndocument.registerElement(\"storage-form\", StorageForm);\n\n\n\n// WEBPACK FOOTER //\n// ./src/storage-elements-registerer.js","export type Area = string;\n\nexport interface AreaHandler {\n  read(name: string): Promise<?string>;\n  write(name: string, newValue: string): Promise<void>;\n  removeItem(name: string): Promise<void>;\n}\n\nconst handlers: { [area: Area]: AreaHandler } = {};\n\nexport function registerHandler(area: Area, handler: AreaHandler): void {\n  if (handlers[area]) {\n    throw Error(`Already registered handler for \"${area}\"`);\n  }\n  handlers[area] = handler;\n}\n\nexport function findHandler(area: Area): ?AreaHandler {\n  return handlers[area];\n}\n\nexport class WebStorageAreaHandler {\n  storage: Storage;\n\n  constructor(storage: Storage) {\n    this.storage = storage;\n  }\n\n  read(name: string): Promise<?string> {\n    return Promise.resolve(this.storage.getItem(name));\n  }\n\n  write(name: string, newValue: string): Promise<void> {\n    this.storage.setItem(name, newValue);\n    return Promise.resolve();\n  }\n\n  removeItem(name: string): Promise<void> {\n    this.storage.removeItem(name);\n    return Promise.resolve();\n  }\n}\n\nexport class ChromeStorageAreaHandler {\n  storage: ChromeStorageArea;\n\n  constructor(storage: ChromeStorageArea) {\n    this.storage = storage;\n  }\n\n  read(name: string): Promise<?string> {\n    return new Promise((resolve) => this.storage.get(name, (v) => resolve(v[name])));\n  }\n\n  write(name: string, newValue: string): Promise<void> {\n    return new Promise((resolve) => this.storage.set({ [name]: newValue }, resolve));\n  }\n\n  removeItem(name: string): Promise<void> {\n    return new Promise((resolve) => this.storage.remove(name, resolve));\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/area-handler.js","import * as u from \"./utils\";\nimport * as ah from \"./area-handler\";\n\ndeclare interface NamableHTMLElement extends HTMLElement {\n  name?: string;\n}\ndeclare interface FormComponentElement extends HTMLElement {\n  name: string;\n\n  value?: string;\n  type?: string;\n  checked?: boolean;\n\n  // <select> element\n  options?: HTMLOptionsCollection;\n  length?: number;\n\n  // <option> element\n  selected?: boolean;\n}\n\ndeclare class Object {\n  static entries<K, V>(o: { [key: K]: V }): Array<[K, V]>\n}\n\n// See https://www.w3.org/TR/html5/infrastructure.html#htmloptionscollection\ndeclare class HTMLOptionsCollection extends HTMLCollection<HTMLOptionElement> {}\n\ndeclare type Name = string\n\n// TODO use Map<Name, Array<string>>\ndeclare type Values = { [key: Name]: Array<string> };\n// TODO use Map<Name, Array<?{ newValue: ?string, oldValue: ?string }>>\ndeclare type ValueChanges = { [key: Name]: Array<?[?string, ?string]> };\n\ndeclare type FormElements = u.MultiValueMap<Name, FormComponentElement>;\n\nconst DEFAULT_SYNC_INTERVAL = 500;\n\nexport default class HTMLStorageFormElement extends HTMLFormElement {\n  values: Values;\n  formElements: FormElements;\n\n  syncTask: ?u.CancellablePromise<void>;\n  scanTask: ?u.CancellablePromise<void>;\n  scanIntervalMillis: number;\n\n  componentObservers: Map<FormComponentElement, MutationObserver>;\n\n  syncPromise: ?Promise<void>;\n\n  get autosync(): number {\n    const n = parseInt(getAttr(this, \"autosync\"));\n    return n > 0 ? n : DEFAULT_SYNC_INTERVAL;\n  }\n  set autosync(v: any) { setAttr(this, \"autosync\", v); }\n  get area(): ah.Area { return getAttr(this, \"area\"); }\n  set area(v: any) { setAttr(this, \"area\", v); }\n\n  constructor() {\n    super();\n  }\n\n  createdCallback() {\n    this.values = {};\n    this.formElements = new u.MultiValueMap();\n    this.scanIntervalMillis = 700;\n    this.componentObservers = new Map();\n    this.syncPromise = null;\n\n    this.addEventListener(\"submit\", (event) => {\n      event.preventDefault();\n      this.sync(null, { noLoad: true });\n    });\n\n    new MutationObserver(() => {\n      console.debug(\"scan by form MutationObserver: \", this);\n      this.scanComponents();\n    }).observe(this, { childList: true, subtree: true });\n\n    this.scanComponents();\n    // this.startPeriodicalScan();\n\n    if (this.isAutoSyncEnabled())\n      this.startPeriodicalSync();\n  }\n\n  attachedCallback() {\n    this.scanComponents();\n\n    if (this.isAutoSyncEnabled())\n      this.startPeriodicalSync();\n\n    // this.startPeriodicalScan();\n  }\n\n  detachedCallback() {\n    if (this.storageSyncTask != null)\n      clearTimeout(this.storageSyncTask);\n    this.stopPeriodicalScan();\n  }\n\n  async startPeriodicalScan() {\n    if (this.scanTask != null) return;\n    while (true) { // this loop will break by stopPeriodicalScan()\n      this.scanTask = u.sleep(this.scanIntervalMillis);\n      await this.scanTask;\n      await this.scanComponents();\n    }\n  }\n  stopPeriodicalScan() {\n    if (this.scanTask == null) return;\n    this.scanTask.cancell();\n    this.scanTask = null;\n  }\n\n  async startPeriodicalSync() {\n    if (this.syncTask != null) return;\n    while (true) { // this loop will break by stopPeriodicalSync()\n      this.syncTask = u.sleep(this.autosync);\n      await this.syncTask;\n      await this.sync();\n    }\n  }\n  stopPeriodicalSync() {\n    if (this.syncTask == null) return;\n    this.syncTask.cancell();\n    this.syncTask = null;\n  }\n\n  async scanComponents() {\n    if (this.syncPromise) await this.syncPromise;\n\n    const lastElements = this.getFormElementSet();\n    const currentElements = this.getCurrentElements();\n\n    const lastNames = new Set(Object.keys(this.values));\n    const currentNames = names(currentElements);\n    const promises = [];\n\n    if (isEqualSet(lastNames, currentNames)\n        && isEqualSet(lastElements, currentElements))\n      return;\n\n    this.formElements = Array.from(currentElements).reduce((map: FormElements, e) => {\n      map.add(e.name, e);\n      return map;\n    }, new u.MultiValueMap());\n\n    const added = u.subtractSet(currentElements, lastElements);\n    if (added.size > 0) {\n      added.forEach(this.afterComponentAppend, this);\n    }\n\n    const addedNames = u.subtractSet(currentNames, lastNames);\n    Array.from(added).map(e => e.name).forEach(addedNames.add, addedNames);\n    if (addedNames.size > 0) {\n      promises.push(this.sync(Array.from(addedNames)));\n    }\n\n    const removed = u.subtractSet(lastElements, currentElements);\n    if (removed.size > 0) {\n      removed.forEach(this.afterComponentRemove, this);\n    }\n\n    const removedNames = u.subtractSet(lastNames, currentNames);\n    if (removedNames.size > 0) {\n      for (const n of removedNames) {\n        console.debug(\"Removed name: %o\", n);\n        delete this.values[n];\n      }\n    }\n\n    for (const p of promises) await p;\n  }\n\n  getCurrentElements(): Set<FormComponentElement> {\n    return new Set(Array.from(this.elements).filter((e: NamableHTMLElement) => e.name));\n  }\n\n  getFormElementSet(): Set<FormComponentElement> {\n    return Array.from(this.formElements.values())\n      .reduce((set, elements) => {\n        elements.forEach(set.add, set);\n        return set;\n      }, new Set());\n  }\n\n  afterComponentAppend(e: FormComponentElement) {\n    console.debug(\"afterComponentAppend: %o\", e);\n    const o = new MutationObserver(() => {\n      console.debug(\"scan by \\\"name\\\" atter MutationObserver: \", e);\n      this.scanComponents();\n    });\n    o.observe(e, { attributes: true, attributeFilter: [\"name\"] });\n    this.componentObservers.set(e, o);\n  }\n\n  afterComponentRemove(e: FormComponentElement) {\n    console.debug(\"afterComponentRemove: %o\", e);\n    const o = this.componentObservers.get(e);\n    if (o) o.disconnect();\n  }\n\n  /// partial load if `names` was provided\n  async load(names?: ?Array<Name>) {\n    const storageValues = await this.readStorageAll();\n    const storageChanges = this.diffValues(storageValues, this.values);\n\n    if (!names) names = Object.keys(storageChanges);\n\n    if (names.length === 0) return;\n\n    const subChanges = {};\n    for (const n of names) {\n      this.values[n] = storageValues[n];\n      subChanges[n] = storageChanges[n] || [];\n    }\n    this.writeForm(subChanges);\n  }\n\n  /// partial store if `names` was provided\n  async store(names?: ?Array<Name>) {\n    const formValues = this.readFormAll();\n    const formChanges = this.diffValues(formValues, this.values);\n\n    if (!names) names = Object.keys(formChanges);\n\n    if (names.length === 0) return;\n\n    const subChanges = {};\n    for (const n of names) {\n      this.values[n] = formValues[n];\n      subChanges[n] = formChanges[n] || [];\n    }\n    await this.writeStorage(subChanges);\n  }\n\n  diffValues(newValues: Values, oldValues: Values): ValueChanges {\n    const names: Array<Name> = u.dedup(Object.keys(newValues).concat(Object.keys(oldValues)));\n    return names.reduce((result: ValueChanges, name: Name): ValueChanges => {\n      if (newValues[name] == null) newValues[name] = [];\n      if (oldValues[name] == null) oldValues[name] = [];\n      const values = [];\n      const len = Math.max(newValues[name].length, oldValues[name].length);\n      for (let i = 0; i < len; i++) {\n        const newValue = newValues[name][i];\n        const oldValue = oldValues[name][i];\n        values[i] = newValue === oldValue ? null : [newValue, oldValue];\n      }\n      if (values.some((v) => v !== null))\n        result[name] = values;\n      return result;\n    }, {});\n  }\n\n  async readStorageAll(): Promise<Values> {\n    // start all data fatching at first\n    const ps = Array.from(this.formElements.flattenValues())\n          .reduce((values, e) => {\n            const n = e.name;\n            values[n] = this.readStorageByName(n);\n            return values;\n          }, {});\n\n    // resolve promises\n    const result = {};\n    for (const [name, promise] of Object.entries(ps)) {\n      result[name] = await promise;\n    }\n    return result;\n  }\n\n  async readStorageByName(name: string): Promise<Array<string>> {\n    const v = await this.getAreaHandler().read(name);\n    return v == null ? [] : [v];\n  }\n\n  writeForm(changes: ValueChanges) {\n    for (const [name, changeArray] of Object.entries(changes)) {\n      const change = changeArray[0];\n      const [newValue] = change == null ? [] : change;\n      const elements = this.formElements.get(name);\n\n      if (elements == null) continue;\n\n      console.debug(\"write to form: name=%s, value=%s, elements=%o\", name, newValue, elements);\n\n      elements.forEach((e) => {\n        if (e.type === \"checkbox\" || e.type === \"radio\") {\n          e.checked = newValue === e.value;\n          return;\n        }\n\n        if (e.value != null) {\n          if (newValue == null) return;\n          e.value = newValue;\n          return;\n        }\n\n        console.error(\"Unsupported element: %o\", e);\n      });\n    }\n  }\n\n  async writeStorage(changes: ValueChanges) {\n    const handler = this.getAreaHandler();\n    const promises = Object.entries(changes).map(async ([name, chageArray]) => {\n      const c = chageArray[0];\n      if (c == null) return;\n      const [newValue] = c;\n\n      if (newValue == null) {\n        console.debug(\"remove from storage: name=%o\", name);\n        await handler.removeItem(name);\n      } else {\n        console.debug(\"write to storage: name=%o, value=%o\", name, newValue);\n        await handler.write(name, newValue);\n      }\n    });\n    await Promise.all(promises);\n  }\n\n  readFormAll(): Values {\n    return Array.from(this.formElements.flattenValues())\n      .reduce((items: Values, element) => {\n        if (element.value == null) return items;\n\n        const n = element.name;\n        if (items[n] == null) items[n] = [];\n\n        if (element.type === \"checkbox\" || element.type === \"radio\") {\n          if (element.checked) items[n].push(element.value);\n          return items;\n        }\n\n        // expand a <select> element to <option> elements.\n        if (element.options != null) {\n          for (const opt of element.options) {\n            if (opt.selected) items[n].push(opt.value);\n          }\n          return items;\n        }\n\n        items[n].push(element.value);\n        return items;\n      }, {});\n  }\n\n  getAreaHandler(): ah.AreaHandler {\n    const a: ?ah.Area = this.getArea();\n    if (!a) throw Error(\"\\\"area\\\" attribute is required\");\n\n    const h = ah.findHandler(a);\n    if (!h) throw Error(`Unsupported area: \"${a}\"`);\n    return h;\n  }\n\n  getArea(): ?ah.Area {\n    const a = this.getAttribute(\"area\");\n    if (a) return a;\n    return null;\n  }\n\n  async sync(names?: ?Array<Name>, opt?: { noLoad: boolean } = { noLoad: false }) {\n    if (this.syncPromise) await this.syncPromise;\n    this.syncPromise = (async () => {\n      if (!opt.noLoad) await this.load(names);\n      await this.store(names);\n      this.syncPromise = null;\n    })();\n    await this.syncPromise;\n  }\n\n  isAutoSyncEnabled(): boolean {\n    return this.hasAttribute(\"autosync\");\n  }\n\n  static get observedAttributes() {\n    return [\n      \"autosync\",\n      \"area\",\n    ];\n  }\n\n  attributeChangedCallback(attrName: string) {\n    switch (attrName) {\n    case \"autosync\":\n      if (this.isAutoSyncEnabled()) {\n        this.startPeriodicalSync();\n      } else {\n        this.stopPeriodicalSync();\n      }\n      break;\n    case \"area\":\n      this.values = {};\n      this.formElements = new u.MultiValueMap();\n      break;\n    }\n  }\n}\n\nfunction isEqualSet<T>(a: Set<T>, b: Set<T>): boolean {\n  if (a.size !== b.size) return false;\n  for (const t of a) {\n    if (!b.has(t)) return false;\n  }\n  for (const t of b) {\n    if (!a.has(t)) return false;\n  }\n  return true;\n}\nfunction names(iter: Iterable<FormComponentElement>): Set<Name> {\n  return new Set(map(iter, (v) => v.name));\n}\nfunction map<T, U>(iter: Iterable<T>,\n                   callbackfn: (value: T, index: number, array: Array<T>) => U,\n                   thisArg?: any): Array<U> {\n  return Array.from(iter).map(callbackfn, thisArg);\n}\nfunction getAttr(self: HTMLElement, name: string): string {\n  const v = self.getAttribute(name);\n  return v ? v : \"\";\n}\nfunction setAttr(self: HTMLElement, name: string, value: ?string) {\n  if (value == null) return;\n  self.setAttribute(name, value);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/storage-form.js","export class CancellablePromise<R> extends Promise<R> {\n  cancellFunction: () => void;\n  constructor(\n    callback: (\n      resolve: (result: Promise<R> | R) => void,\n      reject: (error: any) => void\n    ) => mixed,\n    cancell: () => void\n  ) {\n    super(callback);\n    this.cancellFunction = cancell;\n  }\n\n  cancell() {\n    this.cancellFunction();\n  }\n}\n\nexport function sleep(msec: number): CancellablePromise<void> {\n  let timeoutId: ?number;\n  return new CancellablePromise(\n    (resolve) => {\n      timeoutId = setTimeout(() => resolve(), msec);\n    },\n    () => {\n      clearTimeout(timeoutId);\n    }\n  );\n}\n\nexport function dedup<T>(array: Array<T>,\n                         predicate?: (t: T, o: T) => boolean = (t, o) => t === o): Array<T> {\n  return array.reduce((result: Array<T>, element) => {\n    if (result.some((i) => predicate(i, element))) result;\n    return result.concat(element);\n  },[]);\n}\n\nexport function subtractSet<T>(targetSet: Set<T>, removedSet: Set<T>): Set<T> {\n  return new Set(Array.from(targetSet).filter((e) => !removedSet.has(e)));\n}\n\nexport class MultiValueMap<K, V> extends Map<K, Array<V>> {\n  add(key: K, value: V): this {\n    let a = this.get(key);\n    if (!a) {\n      a = [];\n      this.set(key, a);\n    }\n    a.push(value);\n    return this;\n  }\n\n  * flattenValues(): Iterator<V> {\n    for (const arr of this.values()) {\n      for (const v of arr) {\n        yield v;\n      }\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""}