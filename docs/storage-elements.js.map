{"version":3,"sources":["webpack:///webpack/bootstrap 35dbb1f521f8a655434c","webpack:///./src/storage-elements-registerer.js","webpack:///./src/utils.js","webpack:///./src/area-handler.js","webpack:///./src/binder.js","webpack:///./src/area-select.js","webpack:///./src/storage-form.js"],"names":[],"mappings":"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","file":"storage-elements.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 35dbb1f521f8a655434c","// @flow\nimport StorageFormElement from \"./storage-form\";\n\nStorageFormElement.register();\n\n\n\n// WEBPACK FOOTER //\n// ./src/storage-elements-registerer.js","// @flow\n\nexport class CancellablePromise<R> extends Promise<R> {\n  cancellFunction: () => void;\n  constructor(\n    callback: (\n      resolve: (result: Promise<R> | R) => void,\n      reject: (error: any) => void\n    ) => mixed,\n    cancell: () => void\n  ) {\n    super(callback);\n    this.cancellFunction = cancell;\n  }\n\n  cancell() {\n    this.cancellFunction();\n  }\n}\n\nexport function sleep(msec: number): CancellablePromise<void> {\n  let timeoutId: ?number;\n  return new CancellablePromise(\n    (resolve) => {\n      timeoutId = setTimeout(() => resolve(), msec);\n    },\n    () => {\n      clearTimeout(timeoutId);\n    }\n  );\n}\n\nexport function dedup<T>(array: Array<T>,\n                         predicate?: (t: T, o: T) => boolean = (t, o) => t === o): Array<T> {\n  return array.reduce((result: Array<T>, element) => {\n    if (result.some((i) => predicate(i, element))) result;\n    return result.concat(element);\n  },[]);\n}\n\nexport function subtractSet<T>(targetSet: Set<T>, removedSet: Set<T>): Set<T> {\n  return new Set(Array.from(targetSet).filter((e) => !removedSet.has(e)));\n}\n\nclass MultiValueMap<K, V, I: Iterable<V>> extends Map<K, I> {\n  * flattenValues(): Iterator<V> {\n    for (const arr of this.values()) {\n      for (const v of arr) {\n        yield v;\n      }\n    }\n  }\n}\n\nexport class ArrayValueMap<K, V> extends MultiValueMap<K, V, Array<V>> {\n  add(key: K, value: V): this {\n    let a = this.get(key);\n    if (!a) {\n      a = [];\n      this.set(key, a);\n    }\n    a.push(value);\n    return this;\n  }\n}\n\nexport class SetValueMap<K, V> extends MultiValueMap<K, V, Set<V>> {\n  add(key: K, value: V): this {\n    let a = this.get(key);\n    if (!a) {\n      a = new Set();\n      this.set(key, a);\n    }\n    a.add(value);\n    return this;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","// @flow\n/* global chrome */\n\nexport type Area = string;\n\nexport interface AreaHandler {\n  read(name: string): Promise<?string>;\n  write(name: string, newValue: string): Promise<void>;\n  remove(name: string): Promise<void>;\n}\n\nconst handlers: { [area: Area]: AreaHandler } = {};\n\nexport function registerHandler(area: Area, handler: AreaHandler): void {\n  if (handlers[area]) {\n    throw Error(`Already registered handler for \"${area}\"`);\n  }\n  handlers[area] = handler;\n}\n\nexport function findHandler(area: Area): ?AreaHandler {\n  return handlers[area];\n}\n\nexport function listHandlers(): Array<[Area, AreaHandler]> {\n  return Object.entries(handlers);\n}\n\n//\n\nexport class WebStorageAreaHandler {\n  storage: Storage;\n\n  constructor(storage: Storage) {\n    this.storage = storage;\n  }\n\n  read(name: string): Promise<?string> {\n    return Promise.resolve(this.storage.getItem(name));\n  }\n\n  write(name: string, newValue: string): Promise<void> {\n    this.storage.setItem(name, newValue);\n    return Promise.resolve();\n  }\n\n  remove(name: string): Promise<void> {\n    this.storage.removeItem(name);\n    return Promise.resolve();\n  }\n}\n\nif (typeof localStorage !== \"undefined\")\n  registerHandler(\"local-storage\", new WebStorageAreaHandler(localStorage));\nif (typeof sessionStorage !== \"undefined\")\n  registerHandler(\"session-storage\", new WebStorageAreaHandler(sessionStorage));\n\n//\n\nexport class ChromeStorageAreaHandler {\n  storage: ChromeStorageArea;\n\n  constructor(storage: ChromeStorageArea) {\n    this.storage = storage;\n  }\n\n  read(name: string): Promise<?string> {\n    return new Promise((resolve) => this.storage.get(name, (v) => resolve(v[name])));\n  }\n\n  write(name: string, newValue: string): Promise<void> {\n    return new Promise((resolve) => this.storage.set({ [name]: newValue }, resolve));\n  }\n\n  remove(name: string): Promise<void> {\n    return new Promise((resolve) => this.storage.remove(name, resolve));\n  }\n}\n\nexport class BatchWriteChromeStorageAreaHandler extends ChromeStorageAreaHandler {\n  delayMillis: number;\n  updatedEntries: ?{ [k: string]: string };\n\n  constructor(storage: ChromeStorageArea & { MAX_WRITE_OPERATIONS_PER_HOUR: number }) {\n    super(storage);\n    // what interval we should keep for a write operation.\n    this.delayMillis = (60 * 60 * 1000 / storage.MAX_WRITE_OPERATIONS_PER_HOUR) + 500;\n    this.updatedEntries = null;\n  }\n\n  write(name: string, newValue: string): Promise<void> {\n    if (this.updatedEntries != null) {\n      this.updatedEntries[name] = newValue;\n      return Promise.resolve();\n    }\n\n    this.updatedEntries = { [name]: newValue };\n    setTimeout(() => {\n      if (this.updatedEntries == null) return;\n      this.storage.set(this.updatedEntries);\n      this.updatedEntries = null;\n    }, this.delayMillis);\n\n    return Promise.resolve();\n  }\n}\n\nif (typeof chrome !== \"undefined\" && chrome.storage) {\n  if (chrome.storage.local)\n    registerHandler(\"chrome-local\", new ChromeStorageAreaHandler(chrome.storage.local));\n  if (chrome.storage.sync)\n    registerHandler(\"chrome-sync\", new BatchWriteChromeStorageAreaHandler(chrome.storage.sync));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/area-handler.js","// @flow\n\nimport * as u from \"./utils\";\n\ndeclare type Name = string;\ndeclare type Value = string;\ndeclare type NameValue = { name: Name, value: ?Value };\ndeclare type Values = Map<Element, NameValue>;\nexport interface Element {\n  name: Name;\n}\ndeclare interface StorageHandler {\n  read(n: Name): Promise<?Value>;\n  write(n: Name, v: Value): Promise<void>;\n  remove(n: Name): Promise<void>;\n}\ndeclare interface FormHandler {\n  write(e: Element, v: ?Value): void;\n  read(e: Element): Value;\n}\n\nexport default class Binder {\n  v: Values;\n  s: StorageHandler;\n  f: FormHandler;\n  lock: ?Promise<mixed>;\n\n  constructor(s: StorageHandler, f: FormHandler) {\n    this.v = new Map;\n    this.s = s;\n    this.f = f;\n    this.lock = null;\n  }\n\n  async sync(targets: Array<Element>): Promise<void> {\n    await syncBlock(this, () => doSync(this, targets));\n  }\n\n  /// Force write form values to the storage\n  async submit(targets: Array<Element>): Promise<void> {\n    await syncBlock(this, () => Promise.all(targets.map(async (e) => {\n      await store(this, e);\n    })));\n  }\n\n  /// Sync only new elements\n  async scan(targets: Array<Element>): Promise<void> {\n    await syncBlock(this, async () => {\n      const newElements = u.subtractSet(new Set(targets), new Set(this.v.keys()));\n      await doSync(this, Array.from(newElements));\n    });\n  }\n\n  /// Invork if an element was removed from a form.\n  async remove(elements: Array<Element>) {\n    await syncBlock(this, async () => {\n      for (const e of elements) this.v.delete(e);\n    });\n  }\n}\n\nasync function doSync(self: Binder, targets: Array<Element>) {\n  await Promise.all(targets.map(async (e) => {\n    await load(self, e);\n    await store(self, e);\n  }));\n}\n\nasync function syncBlock(self: Binder, fn: () => Promise<mixed>) {\n  while (self.lock) await self.lock;\n  self.lock = fn();\n  await self.lock;\n  self.lock = null;\n}\n\nasync function load(self: Binder, elem: Element): Promise<void> {\n  const newN = elem.name;\n  const newV = await self.s.read(newN);\n  let nv: ?NameValue = self.v.get(elem);\n  if (!nv) {\n    nv = { name: elem.name, value: null };\n    self.v.set(elem, nv);\n  }\n  if (nv.name !== newN || nv.value !== newV) {\n    self.f.write(elem, newV);\n    nv.name =  newN;\n    nv.value =  newV;\n  }\n}\n\nasync function store(self: Binder, elem: Element): Promise<void> {\n  const newN = elem.name;\n  const newV = self.f.read(elem);\n  let nv: ?NameValue = self.v.get(elem);\n  if (!nv) {\n    nv = { name: elem.name, value: null };\n    self.v.set(elem, nv);\n  }\n  if (nv.name !== newN || nv.value !== newV) {\n    if (newV == null) {\n      await self.s.remove(newN);\n    } else {\n      await self.s.write(newN, newV);\n    }\n    nv.name =  newN;\n    nv.value =  newV;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/binder.js","// @flow\n\nimport * as u from \"./utils\";\nimport * as ah from \"./area-handler\";\nimport Binder from \"./binder\";\n\ndeclare type Value = string;\n\ninterface AreaSelect extends HTMLSelectElement {\n  area: string;\n}\n\ninterface InternalAreaSelect extends AreaSelect {\n  isInitLoad: boolean;\n  binder: ?Binder;\n}\n\nconst SYNC_INTERVAL = 500;\n\nexport function mixinAreaSelect<T: HTMLSelectElement>(c: Class<T>): Class<T & AreaSelect> {\n  // $FlowFixMe Force cast to the returned type.\n  return class extends c {\n    isInitLoad: boolean;\n    binder: ?Binder;\n\n    get area(): ah.Area { return getAttr(this, \"area\"); }\n    set area(v: any) { setAttr(this, \"area\", v); }\n\n    constructor() {\n      super();\n    }\n\n    createdCallback() {\n      this.isInitLoad = true;\n\n      this.addEventListener(\"change\", () => sync(this));\n      window.addEventListener(\"unload\", () => sync(this));\n\n      // Periodical sync\n      // To observe storage changings and `.value` changings by an external javascripts\n      (async () => {\n        while (true) {\n          await u.sleep(SYNC_INTERVAL);\n          await sync(this);\n          writeArea(this);\n        }\n      })();\n    }\n\n    attachedCallback() {\n      if (this.length === 0) addAllHandlers(this);\n      initBinder(this);\n      writeArea(this);\n    }\n\n    static get observedAttributes() { return [\"area\"]; }\n\n    attributeChangedCallback(attrName: string) {\n      switch (attrName) {\n      case \"area\":\n        initBinder(this);\n        break;\n      }\n    }\n  };\n}\n\nconst mixedSelect = mixinAreaSelect(HTMLSelectElement);\nexport default class HTMLAreaSelectElement extends mixedSelect {\n  static get extends() { return \"select\"; }\n}\n\nasync function initBinder(self: InternalAreaSelect): Promise<void> {\n  // Avoid to initalize until <option> elements are appended\n  if (self.options.length === 0) return;\n\n  self.binder = null;\n\n  const h = getAreaHandler(self);\n  if (!h) return;\n\n  self.binder = new Binder(h, { write: writeSelect, read: readSelect });\n\n  if (self.isInitLoad) {\n    self.isInitLoad = false;\n    await sync(self);\n  } else {\n    await submit(self);\n  }\n}\n\nfunction writeSelect(self: any, newValue: ?Value): void {\n  if (self.value === newValue) return;\n  self.value = newValue;\n  writeArea(self);\n}\n\nfunction readSelect(self: any): Value { return self.value; }\n\nasync function submit(self: InternalAreaSelect): Promise<void> {\n  if (self.binder) await self.binder.submit([self]);\n}\n\nasync function sync(self: InternalAreaSelect): Promise<void> {\n  if (self.binder) await self.binder.sync([self]);\n}\n\nfunction writeArea(self: InternalAreaSelect) {\n  const form = self.form;\n  if (form == null) return;\n  form.setAttribute(\"area\", self.value);\n}\n\nfunction getAreaHandler(self: InternalAreaSelect): ?ah.AreaHandler {\n  const a = self.area;\n  if (!a) {\n    console.debug(\"Require 'area' attribute\", self);\n    return null;\n  }\n  const h = ah.findHandler(a);\n  if (!h) {\n    console.debug(\"No such area handler: area=%s, this=%s\", self.area, self);\n    return null;\n  }\n  return h;\n}\n\nfunction addAllHandlers(self: InternalAreaSelect) {\n  for (const [area] of ah.listHandlers()) {\n    const o = document.createElement(\"option\");\n    o.innerHTML = area;\n    self.appendChild(o);\n  }\n}\n\nfunction getAttr(self: HTMLElement, name: string): string {\n  const v = self.getAttribute(name);\n  return v ? v : \"\";\n}\nfunction setAttr(self: HTMLElement, name: string, value: ?string): void {\n  if (value == null) return;\n  self.setAttribute(name, value);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/area-select.js","// @flow\n\nimport * as u from \"./utils\";\n\nimport Binder from \"./binder\";\nimport type { Element } from \"./binder\";\n\nimport * as ah from \"./area-handler\";\nimport AreaSelect from \"./area-select\";\n\ndeclare type Name = string;\ndeclare type Value = string;\n\ndeclare interface FormComponentElement extends HTMLElement {\n  name: Name;\n  value?: Value;\n  type?: string;\n  checked?: boolean;\n}\n\nexport interface StorageForm extends HTMLFormElement {\n  autosync: number;\n  area: string;\n}\n\ndeclare interface InternalStorageForm extends StorageForm {\n  isInitLoad: boolean;\n  binder: ?Binder;\n  componentObservers: Map<FormComponentElement, MutationObserver>;\n}\n\nconst DEFAULT_SYNC_INTERVAL = 700;\n\nexport function mixinStorageForm<T: HTMLFormElement>(c: Class<T>): Class<T & StorageForm> {\n  // $FlowFixMe Force cast to the returned type.\n  return class extends c {\n    isInitLoad: boolean;\n    binder: ?Binder;\n    componentObservers: Map<FormComponentElement, MutationObserver>;\n\n    get autosync(): number {\n      const n = parseInt(getAttr(this, \"autosync\"));\n      return n > 0 ? n : DEFAULT_SYNC_INTERVAL;\n    }\n    set autosync(v: any) { setAttr(this, \"autosync\", v); }\n    get area(): ah.Area { return getAttr(this, \"area\"); }\n    set area(v: any) { setAttr(this, \"area\", v); }\n\n    constructor() {\n      super();\n    }\n\n    createdCallback() {\n      this.isInitLoad = true;\n      this.componentObservers = new Map();\n\n      initBinder(this);\n\n      this.addEventListener(\"submit\", (event) => {\n        event.preventDefault();\n        submit(this);\n      });\n\n      window.addEventListener(\"unload\", () => {\n        if (isAutoSyncEnabled(this)) {\n          sync(this);\n        }\n      });\n\n      new MutationObserver((records) => {\n        console.debug(\"scan by form MutationObserver: \", this);\n        scan(this);\n\n        const added: Array<HTMLElement> =\n              flatten(records.map(r => (r.addedNodes: Iterable<any>)))\n              .filter((e) => e instanceof HTMLElement);\n        if (added.length > 0) {\n          for (const e of added) {\n            observeComponent(this, e);\n          }\n        }\n\n        const removed: Array<HTMLElement> =\n              flatten(records.map((r) => (r.removedNodes: Iterable<any>)))\n              .filter((e) => e instanceof HTMLElement);\n        if (removed.length > 0) {\n          // Use \"any\" to force cast to Array<FormComponentElements>\n          remove(this, (removed.filter((e) => (e: any).name): Array<any>));\n          for (const e of removed) {\n            disconnectComponent(this, e);\n          }\n        }\n      }).observe(this, { childList: true, subtree: true });\n\n      scan(this);\n\n      // Periodical scan/sync\n      // To observe:\n      //   * storage value changings\n      //   * external form components (such as a <input form=\"...\" ...>)\n      //   * form value changings by an external javascript\n      (async () => {\n        while (true) {\n          await u.sleep(this.autosync);\n          if (isAutoSyncEnabled(this)) {\n            await sync(this);\n          } else {\n            await scan(this);\n          }\n        }\n      })();\n    }\n\n    attachedCallback() {\n      scan(this);\n    }\n\n    static get observedAttributes() {\n      return [\n        \"autosync\",\n        \"area\",\n      ];\n    }\n\n    attributeChangedCallback(attrName: string) {\n      switch (attrName) {\n      case \"autosync\":\n        break;\n      case \"area\":\n        initBinder(this);\n        break;\n      }\n    }\n  };\n}\n\nconst mixedForm = mixinStorageForm(HTMLFormElement);\nexport default class HTMLStorageFormElement extends mixedForm {\n  static get extends() { return \"form\"; }\n\n  static register() {\n    // Custom Element v1 seems not to works right to extend <form> in Google Chrome 55\n    // See http://stackoverflow.com/a/41458692/3864351\n    // Polyfill too: https://github.com/webcomponents/custom-elements/tree/master/src\n    // > To do: Implement built-in element extension (is=)\n    // customElements.define(\"storage-form\", StorageFormElement, { extends: \"form\" });\n    // window.StorageFormElement = StorageFormElement;\n\n    // Custom Element v0\n    document.registerElement(\"storage-form\", HTMLStorageFormElement);\n    document.registerElement(\"area-select\", AreaSelect);\n  }\n}\n\nfunction isAutoSyncEnabled(self: HTMLFormElement): boolean {\n  return self.hasAttribute(\"autosync\");\n}\n\nasync function submit(self: InternalStorageForm): Promise<void> {\n  if (self.binder) await self.binder.submit(elements(self));\n}\n\nasync function sync(self: InternalStorageForm, targets?: Array<Element>): Promise<void> {\n  if (self.binder) await self.binder.sync(targets ? targets : elements(self));\n}\n\nasync function scan(self: InternalStorageForm): Promise<void> {\n  if (self.binder) await self.binder.scan(elements(self));\n}\n\nasync function remove(self: InternalStorageForm, elems: Array<Element>): Promise<void> {\n  if (self.binder) await self.binder.remove(elems);\n}\n\nfunction observeComponent(self: InternalStorageForm, newElement: HTMLElement): void {\n  const elements: Array<FormComponentElement> =\n        // force cast\n        ([newElement, ...Array.from(newElement.querySelectorAll(\"*\"))]\n         .filter((e) => (e: any).value != null && (e: any).name != null): any);\n\n  for (const e of elements) {\n    const o = new MutationObserver(() => sync(self, [e]));\n    o.observe(e, { attributes: true, atributeFilter: [\"name\"] });\n    self.componentObservers.set(e, o);\n  }\n}\n\nfunction disconnectComponent(self: InternalStorageForm, element: HTMLElement): void {\n  const elements = [element, ...Array.from(element.querySelectorAll(\"*\"))];\n  for (const e of elements) {\n    const o = self.componentObservers.get((e: any));\n    if (o == null) continue;\n    self.componentObservers.delete((e: any));\n    o.disconnect();\n  }\n}\n\nfunction elements(self: InternalStorageForm): Array<Element> {\n  return Array.from(((self.elements): Iterable<any>))\n    .filter(e => e.name)\n    .filter(e => !(e instanceof AreaSelect));\n}\n\nasync function initBinder(self: InternalStorageForm): Promise<void> {\n  self.binder = null;\n\n  const h = getAreaHandler(self);\n  if (!h) return;\n\n  self.binder = new Binder(h, { write: writeForm, read: readForm });\n  if (self.isInitLoad) {\n    self.isInitLoad = false;\n    await sync(self);\n  } else {\n    await submit(self);\n  }\n\n  self.dispatchEvent(new CustomEvent(\"storage-form-init\", { detail: { target: self }}));\n}\n\nfunction writeForm(component: any, newValue: ?Value): void {\n  const type = component.type;\n  if (type === \"checkbox\" || type === \"radio\") {\n    component.checked = newValue === component.value;\n    return;\n  }\n\n  if (newValue == null || component.value == null)\n    return;\n\n  component.value = newValue;\n}\n\nfunction readForm(component: any): Value {\n  const type = component.type;\n  if (type === \"checkbox\" || type === \"radio\") {\n    if (component.checked) {\n      return component.value;\n    }\n    const uncheckedValue = component.dataset.uncheckedValue;\n    if (uncheckedValue) {\n      return uncheckedValue;\n    }\n    return \"\";\n  }\n  return component.value;\n}\n\nfunction getAreaHandler(self: InternalStorageForm): ?ah.AreaHandler {\n  const a = self.area;\n  if (!a) {\n    console.debug(\"Require 'area' attribute\", self);\n    return null;\n  }\n  const h = ah.findHandler(a);\n  if (!h) {\n    console.debug(\"No such area handler: area=%s, this=%o\", self.area, self);\n    return null;\n  }\n  return h;\n}\n\nfunction getAttr(self: HTMLElement, name: string): string {\n  const v = self.getAttribute(name);\n  return v ? v : \"\";\n}\nfunction setAttr(self: HTMLElement, name: string, value: ?string): void {\n  if (value == null) return;\n  self.setAttribute(name, value);\n}\n\nfunction flatten<T>(iteriter: Iterable<Iterable<T>>): Array<T> {\n  return Array.from((function* () {\n    for (const iter of iteriter) for (const t of iter) yield t;\n  })());\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/storage-form.js"],"sourceRoot":""}