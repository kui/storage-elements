{"version":3,"sources":["webpack:///webpack/bootstrap 0e4deb3674887af2676f","webpack:///./src/storage-elements-registerer.js","webpack:///./src/area-handler.js","webpack:///./src/storage-binder.js","webpack:///./src/utils.js","webpack:///./src/area-select.js","webpack:///./src/binder.js","webpack:///./src/load-button.js","webpack:///./src/storage-form.js"],"names":[],"mappings":"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","file":"storage-elements.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0e4deb3674887af2676f","// @flow\nimport StorageFormElement from \"./storage-form\";\n\nStorageFormElement.register();\n\n\n\n// WEBPACK FOOTER //\n// ./src/storage-elements-registerer.js","// @flow\n/* global chrome */\n\nexport type Area = string;\n\nexport interface AreaHandler {\n  read(names: string[]): Promise<{ [name: string]: ?string }>;\n  write(items: { [name: string]: string }): Promise<void>;\n}\n\nconst handlers: { [area: Area]: AreaHandler } = {};\n\nexport function registerHandler(area: Area, handler: AreaHandler): void {\n  if (handlers[area]) {\n    throw Error(`Already registered handler for \"${area}\"`);\n  }\n  handlers[area] = handler;\n}\n\nexport function findHandler(area: Area): ?AreaHandler {\n  return handlers[area];\n}\n\nexport function listHandlers(): Array<[Area, AreaHandler]> {\n  return Object.entries(handlers);\n}\n\n//\n\nexport class WebStorageAreaHandler {\n  storage: Storage;\n\n  constructor(storage: Storage) {\n    this.storage = storage;\n  }\n\n  read(names: string[]): Promise<{ [name: string]: ?string }> {\n    const r = names\n          .map((n) => [n, this.storage.getItem(n)])\n          .reduce((o, [n, v]) => { o[n] = v; return o; }, {});\n    return Promise.resolve(r);\n  }\n\n  write(items: { [name: string]: string }): Promise<void> {\n    for (const [n, v] of Object.entries(items))\n      this.storage.setItem(n, v);\n    return Promise.resolve();\n  }\n}\n\nif (typeof localStorage !== \"undefined\")\n  registerHandler(\"local-storage\", new WebStorageAreaHandler(localStorage));\nif (typeof sessionStorage !== \"undefined\")\n  registerHandler(\"session-storage\", new WebStorageAreaHandler(sessionStorage));\n\n//\n\nexport class ChromeStorageAreaHandler {\n  storage: ChromeStorageArea;\n\n  constructor(storage: ChromeStorageArea) {\n    this.storage = storage;\n  }\n\n  read(names: string[]): Promise<{ [name: string]: ?string }> {\n    return new Promise((resolve) => this.storage.get(names, resolve));\n  }\n\n  write(items: { [name: string]: string }): Promise<void> {\n    return new Promise((resolve) => this.storage.set(items, resolve));\n  }\n}\n\nexport class BufferedWriteChromeStorageAreaHandler extends ChromeStorageAreaHandler {\n  delayMillis: number;\n  updatedEntries: ?{ [k: string]: string };\n  writePromise: Promise<void>;\n\n  constructor(storage: ChromeStorageArea & { MAX_WRITE_OPERATIONS_PER_HOUR: number }) {\n    super(storage);\n    // what interval we should keep for a write operation.\n    this.delayMillis = (60 * 60 * 1000 / storage.MAX_WRITE_OPERATIONS_PER_HOUR) + 500;\n    this.updatedEntries = null;\n    this.writePromise = Promise.reject(Error(\"Illegal state\"));\n  }\n\n  write(items: { [name: string]: string }): Promise<void> {\n    if (this.updatedEntries != null) {\n      Object.assign(this.updatedEntries, items);\n      return this.writePromise;\n    }\n\n    this.updatedEntries = Object.assign({}, items);\n    this.writePromise = new Promise((resolve) => {\n      setTimeout(() => {\n        if (this.updatedEntries == null) return;\n        this.storage.set(this.updatedEntries, resolve);\n        this.updatedEntries = null;\n      }, this.delayMillis);\n    });\n\n    return this.writePromise;\n  }\n}\n\nif (typeof chrome !== \"undefined\" && chrome.storage) {\n  if (chrome.storage.local)\n    registerHandler(\"chrome-local\", new ChromeStorageAreaHandler(chrome.storage.local));\n  if (chrome.storage.sync)\n    registerHandler(\"chrome-sync\", new BufferedWriteChromeStorageAreaHandler(chrome.storage.sync));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/area-handler.js","// @flow\n\nimport * as utils from \"./utils\";\nimport * as ah from \"./area-handler\";\nimport Binder from \"./binder\";\n\nimport type { DataHandler, StorageHandler } from \"./binder\";\n\nexport interface Bindee {\n  getArea(): ah.Area;\n  isAutoSync(): boolean;\n  isAutoLoad(): boolean;\n  getInterval(): number;\n  getElements(): Iterable<HTMLElement>;\n  getNames(): Iterable<string>;\n  getTarget(): HTMLElement;\n}\n\ndeclare type Change = { oldValue: ?string, newValue: ?string, isChanged: boolean };\n\ndeclare type ChangeEvent = {\n  type: \"load\" | \"submit\" | \"sync\",\n  target: HTMLElement,\n  isForce: boolean,\n};\n\nexport default class StorageBinder {\n  bindee: Bindee;\n  binder: Binder<string, string, Change>;\n  doAutoTask: () => Promise<void>;\n  autoTask: ?utils.CancellablePromise<void>;\n\n  onChange: (e: ChangeEvent) => Promise<void>;\n\n  constructor(bindee: Bindee) {\n    this.bindee = bindee;\n    this.autoTask = null;\n    this.init();\n\n    this.doAutoTask = utils.mergeNextPromise(async () => {\n      if (this.bindee.isAutoSync()) {\n        await this.sync();\n        return;\n      }\n      if (this.bindee.isAutoLoad()) {\n        await this.load();\n        return;\n      }\n    });\n  }\n\n  init() {\n    this.binder = initBinder(this.bindee);\n    this.binder.onChange = async (event) => {\n      const type = { atob: \"load\", btoa: \"submit\", sync: \"sync\"}[event.type];\n      const e = { type, target: this.bindee.getTarget(), isForce: event.isForce };\n      console.debug(\"onChange: \", e);\n      if (this.onChange) {\n        await this.onChange(e);\n      }\n    };\n  }\n\n  async load(o?: { force: boolean }) {\n    await this.binder.aToB(o);\n  }\n\n  async submit(o?: { force: boolean }) {\n    await this.binder.bToA(o);\n  }\n\n  async sync() {\n    await this.binder.sync();\n  }\n\n  async startAutoBinding() {\n    if (this.autoTask) this.autoTask.cancell();\n\n    if (this.bindee.isAutoLoad() || this.bindee.isAutoSync() ) {\n      this.autoTask = utils.periodicalTask({\n        interval: () => this.bindee.getInterval(),\n        task: this.doAutoTask,\n      });\n    } else {\n      this.autoTask = null;\n    }\n  }\n}\n\nfunction initBinder(bindee: Bindee): Binder<string, string, Change> {\n  return new Binder(({\n    a: (new StorageAreaHandler(bindee): StorageHandler<string, string, Change>),\n    b: (new FormHandler(bindee): StorageHandler<string, string, Change>),\n    diff(oldValue: ?string, newValue: ?string): Change {\n      return { oldValue, newValue, isChanged: (oldValue !== newValue) };\n    }\n  }: DataHandler<string, string, Change>));\n}\n\nclass StorageAreaHandler {\n  bindee: Bindee;\n  handler: ?ah.AreaHandler;\n\n  constructor(bindee: Bindee) {\n    this.bindee = bindee;\n    const h = getAreaHandler(bindee);\n    this.handler = h;\n  }\n\n  async readAll(): Promise<Map<string, string>> {\n    if (!this.handler) return new Map;\n    const o: { [n: string]: string } = (await this.handler.read(Array.from(this.bindee.getNames())): any);\n    const a = (Object.entries(o)).filter(([, v]) => v != null);\n    return new Map(a);\n  }\n\n  async write(changes: Iterator<[string, Change]>, isForce: boolean): Promise<void> {\n    if (!this.handler) return;\n    const items = {};\n    for (const [key, { newValue, isChanged }] of changes) {\n      if (isForce || isChanged) items[key] = newValue || \"\";\n    }\n    await this.handler.write(items);\n  }\n}\n\nfunction getAreaHandler(bindee: Bindee): ?ah.AreaHandler {\n  const a = bindee.getArea();\n  if (!a) {\n    console.warn(\"Require 'area' attribute: \", bindee.getTarget());\n    return null;\n  }\n  const h = ah.findHandler(a);\n  if (!h) {\n    console.warn(\"Unsupported 'area':\", a, bindee.getTarget());\n    return null;\n  }\n  return h;\n}\n\nclass FormHandler {\n  bindee: Bindee;\n\n  constructor(bindee: Bindee) {\n    this.bindee = bindee;\n  }\n\n  readAll() {\n    const items = new Map;\n    for (const e of this.bindee.getElements()) {\n      const name: ?string = (e: any).name;\n      if (!name) continue; // filter out empty named elements\n      const prevValue = items.get(name);\n      if (prevValue) continue; // empty value should update other values such as radio list.\n      const value = readValue(e);\n      if (value == null) continue;\n      items.set(name, value);\n    }\n    return Promise.resolve(items);\n  }\n\n  write(changes: Iterator<[string, Change]>, isForce: boolean) {\n    const changeMap = new Map(changes);\n    for (const e of this.bindee.getElements()) {\n      const name: ?string = (e: any).name;\n      if (!name) continue; // filter out empty named elements\n      const change = changeMap.get(name);\n      if (!change) continue;\n      const isChanged = isForce || change.isChanged;\n      if (!isChanged) continue;\n      const value = change.newValue || \"\";\n      writeValue(e, value);\n    }\n    return Promise.resolve();\n  }\n}\n\nfunction readValue(e: HTMLElement): ?string {\n  if ((e instanceof HTMLInputElement) && [\"checkbox\", \"radio\"].includes(e.type)) {\n    if (e.checked) return e.value;\n    if (e.dataset.uncheckedValue) return e.dataset.uncheckedValue;\n    return \"\";\n  } else if (e.value != null) {\n    return (e: any).value;\n  }\n}\n\nfunction writeValue(e: HTMLElement, value: string) {\n  if ((e instanceof HTMLInputElement) && [\"checkbox\", \"radio\"].includes(e.type)) {\n    e.checked = e.value === value;\n  } else if (e.value != null) {\n    (e: any).value = value;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/storage-binder.js","// @flow\n\nexport class CancellablePromise<R> extends Promise<R> {\n  cancell: () => void;\n  constructor(\n    callback: (\n      resolve: (result: Promise<R> | R) => void,\n      reject: (error: any) => void\n    ) => mixed,\n    cancell: () => void\n  ) {\n    super(callback);\n    this.cancell = cancell;\n  }\n}\n\nexport function sleep(msec: number): CancellablePromise<void> {\n  let timeoutId: ?number;\n  return new CancellablePromise(\n    (resolve) => {\n      timeoutId = setTimeout(() => resolve(), msec);\n    },\n    () => {\n      clearTimeout(timeoutId);\n    }\n  );\n}\n\ndeclare type PeriodicalTask = { interval: () => number, task: () => Promise<void> };\n\nexport function periodicalTask(o: PeriodicalTask): CancellablePromise<void> {\n  let sleepPromise;\n  return new CancellablePromise(\n    async () => {\n      do {\n        await o.task();\n        sleepPromise = sleep(o.interval());\n        await sleepPromise;\n      } while (sleepPromise);\n    },\n    () => {\n      if (sleepPromise) sleepPromise.cancell();\n      sleepPromise = null;\n    }\n  );\n}\n\nexport function dedup<T>(array: Array<T>,\n                         predicate?: (t: T, o: T) => boolean = (t, o) => t === o): Array<T> {\n  return array.reduce((result: Array<T>, element) => {\n    if (result.some((i) => predicate(i, element))) result;\n    return result.concat(element);\n  },[]);\n}\n\nexport function subtractSet<T>(targetSet: Set<T>, removedSet: Set<T>): Set<T> {\n  return new Set(Array.from(targetSet).filter((e) => !removedSet.has(e)));\n}\n\nclass MultiValueMap<K, V, I: Iterable<V>> extends Map<K, I> {\n  * flattenValues(): Iterator<V> {\n    for (const arr of this.values()) {\n      for (const v of arr) {\n        yield v;\n      }\n    }\n  }\n}\n\nexport class ArrayValueMap<K, V> extends MultiValueMap<K, V, Array<V>> {\n  add(key: K, value: V): this {\n    let a = this.get(key);\n    if (!a) {\n      a = [];\n      this.set(key, a);\n    }\n    a.push(value);\n    return this;\n  }\n  getOrSetEmpty(key: K): Array<V> {\n    const v = super.get(key);\n    if (v == null) {\n      const n = [];\n      super.set(key, n);\n      return n;\n    } else {\n      return v;\n    }\n  }\n}\n\nexport class SetValueMap<K, V> extends MultiValueMap<K, V, Set<V>> {\n  add(key: K, value: V): this {\n    let a = this.get(key);\n    if (!a) {\n      a = new Set();\n      this.set(key, a);\n    }\n    a.add(value);\n    return this;\n  }\n}\n\nexport function mergeNextPromise(task: () => Promise<void>): () => Promise<void> {\n  let currentPromise: ?Promise<void>;\n  let nextPromise: ?Promise<void>;\n  return async () => {\n    if (nextPromise) {\n      await nextPromise;\n      return;\n    }\n\n    if (currentPromise) {\n      nextPromise = (async () => {\n        if (currentPromise) {\n          await currentPromise;\n        }\n        nextPromise = null;\n\n        currentPromise = task();\n        await currentPromise;\n        currentPromise = null;\n      })();\n\n      await nextPromise;\n      return;\n    }\n\n    currentPromise = (async () => {\n      await task();\n      currentPromise = null;\n    })();\n    await currentPromise;\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","// @flow\n\nimport StorageBinder from \"./storage-binder\";\nimport * as ah from \"./area-handler\";\n\nimport type { Bindee } from \"./storage-binder\";\n\ninterface AreaSelect extends HTMLSelectElement {\n  area: string;\n}\n\ninterface InternalAreaSelect extends AreaSelect {\n}\n\nexport function mixinAreaSelect<T: HTMLSelectElement>(c: Class<T>): Class<T & AreaSelect> {\n  // $FlowFixMe Force cast to the returned type.\n  return class extends c {\n    binder: StorageBinder;\n\n    get area(): ah.Area { return getAttr(this, \"area\"); }\n    set area(v: any) { this.setAttribute(\"area\", v); }\n\n    constructor() {\n      super();\n    }\n\n    createdCallback() {\n      this.binder = new StorageBinder(generateBindee(this));\n      this.binder.onChange = async (event) => {\n        writeArea(this);\n        dispatchEvent(this, `area-select-${event.type}`, event);\n      };\n      observeValue(this, async () => {\n        await this.binder.submit();\n      });\n    }\n\n    attachedCallback() {\n      if (this.length === 0) addAllHandlers(this);\n      this.binder.doAutoTask();\n      writeArea(this);\n    }\n\n    static get observedAttributes() { return [\"area\"]; }\n    attributeChangedCallback(attrName: string) {\n      switch (attrName) {\n      case \"area\":\n        this.binder.init();\n        this.binder.doAutoTask();\n        break;\n      }\n    }\n\n    sync() {\n      if (!this.binder) return Promise.resolve();\n      return this.binder.sync();\n    }\n  };\n}\n\nconst mixedSelect = mixinAreaSelect(HTMLSelectElement);\nexport default class HTMLAreaSelectElement extends mixedSelect {\n  static get extends() { return \"select\"; }\n}\n\nfunction generateBindee(self: InternalAreaSelect): Bindee {\n  return {\n    getArea: () => self.area,\n    getInterval: () => 700,\n    isAutoSync: () => true,\n    isAutoLoad: () => false,\n    getNames: () => [self.name],\n    getElements: () => [self],\n    getTarget: () => self,\n  };\n}\n\nfunction observeValue(self: InternalAreaSelect, onChange: () => Promise<void>) {\n  let value = self.value;\n  (async () => {\n    while (true) {\n      await waitAnimationFrame();\n      if (self.value === value) continue;\n      value = self.value;\n      await onChange();\n    }\n  })();\n}\n\nfunction waitAnimationFrame() {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\nfunction writeArea(self: InternalAreaSelect) {\n  const form = self.form;\n  if (form == null) return;\n  form.setAttribute(\"area\", self.value);\n}\n\nfunction addAllHandlers(self: InternalAreaSelect) {\n  for (const [area] of ah.listHandlers()) {\n    const o = document.createElement(\"option\");\n    o.innerHTML = area;\n    self.appendChild(o);\n  }\n}\n\nfunction dispatchEvent(self: HTMLElement, type: string, detail?: any): boolean {\n  return self.dispatchEvent(new CustomEvent(type, detail));\n}\n\nfunction getAttr(self: HTMLElement, name: string): string {\n  const v = self.getAttribute(name);\n  return v ? v : \"\";\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/area-select.js","// @flow\n\ndeclare interface DiffValue {\n  isChanged: boolean;\n}\n\nexport interface StorageHandler<Key, Value, Changes: DiffValue> {\n  write(c: Iterator<[Key, Changes]>, isForce: boolean): Promise<void>;\n  readAll(): Promise<Map<Key, Value>>;\n}\n\nexport interface DataHandler<Key, Value, Changes: DiffValue> {\n  a: StorageHandler<Key, Value, Changes>;\n  b: StorageHandler<Key, Value, Changes>;\n  diff(oldValue: ?Value, newValue: ?Value): Changes;\n}\n\nexport interface ValueChangeEvent {\n  type: \"atob\" | \"btoa\" | \"sync\";\n  isForce: boolean;\n}\n\nexport default class Binder<Key, Value, Changes: DiffValue> {\n  handler: DataHandler<Key, Value, Changes>;\n  values: Map<Key, Value>;\n  lock: ?Promise<any>;\n  onChange: (e: ValueChangeEvent) => Promise<void>;\n\n  constructor(handler: DataHandler<Key, Value, Changes>) {\n    this.handler = handler;\n    this.values = new Map;\n    this.lock = null;\n  }\n\n  async aToB(o?: { force: boolean } = { force: false }) {\n    const hasChanged =\n          await lockBlock(this, () => readAndWrite(this, this.handler.a, this.handler.b, o.force));\n    if (hasChanged && this.onChange) await this.onChange({ type: \"atob\", isForce: o.force});\n  }\n\n  async bToA(o?: { force: boolean } = { force: false }) {\n    const hasChanged =\n          await lockBlock(this, () => readAndWrite(this, this.handler.b, this.handler.a, o.force));\n    if (hasChanged && this.onChange) await this.onChange({ type: \"btoa\", isForce: o.force});\n  }\n\n  async sync() {\n    let hasChanged = false;\n    await lockBlock(this, async () => {\n      hasChanged = (await readAndWrite(this, this.handler.a, this.handler.b, false)) || hasChanged;\n      hasChanged = (await readAndWrite(this, this.handler.b, this.handler.a, false)) || hasChanged;\n    });\n    if (hasChanged && this.onChange) await this.onChange({ type: \"sync\", isForce: false});\n  }\n}\n\nasync function lockBlock<K, V, C: DiffValue, T>(self: Binder<K, V, C>, fn: () => Promise<T>): Promise<T> {\n  while (self.lock) await self.lock;\n  self.lock = fn();\n  const t = await self.lock;\n  self.lock = null;\n  return t;\n}\n\nasync function readAndWrite<K, V, C: DiffValue, H: StorageHandler<K, V, C>>(\n  self: Binder<K, V, C>, from: H, to: H, isForce: boolean): Promise<boolean> {\n  const newValues = await from.readAll();\n  const oldValues = self.values;\n  self.values = newValues;\n  const keys: Set<K> = new Set(concat(oldValues.keys(), newValues.keys()));\n  let hasChanged = false;\n  const changes = map(keys, (k) => {\n    const d = self.handler.diff(oldValues.get(k), newValues.get(k));\n    hasChanged = hasChanged || d.isChanged;\n    return [k, d];\n  });\n  await to.write(changes, isForce);\n  return hasChanged;\n}\n\nfunction* concat<K>(...iters: Iterable<K>[]): Iterator<K> {\n  for (const iter of iters) for (const k of iter) yield k;\n}\n\nfunction* map<T, U>(iter: Iterable<T>, fn: (t: T) => U): Iterator<U> {\n  for (const t of iter) yield fn(t);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/binder.js","// @flow\n\nexport function mixinLoadButton<T: HTMLButtonElement>(c: Class<T>): Class<T> {\n  // $FlowFixMe Force cast to the returned type.\n  return class extends c {\n    createdCallback() {\n      this.addEventListener(\"click\", (event: MouseEvent) => {\n        event.preventDefault();\n        if (this.form && typeof this.form.load === \"function\") {\n          this.form.load();\n        } else {\n          console.error(\"Unsupported form: \", this.form);\n        }\n      });\n    }\n  };\n}\n\nconst mixedButton = mixinLoadButton(HTMLButtonElement);\nexport default class LoadButton extends mixedButton {\n  static get extends() { return \"button\"; }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/load-button.js","// @flow\n\nimport * as utils from \"./utils\";\nimport StorageBinder from \"./storage-binder\";\nimport * as ah from \"./area-handler\";\nimport AreaSelect from \"./area-select\";\nimport LoadButton from \"./load-button\";\n\nimport type { Bindee } from \"./storage-binder\";\n\ndeclare interface FormControlElement extends HTMLElement {\n  name: string;\n  value?: string;\n  type?: string;\n  checked?: boolean;\n}\n\nexport interface StorageForm extends HTMLFormElement {\n  autosync: boolean;\n  autoload: boolean;\n  interval: number;\n  area: string;\n\n  load(): Promise<void>;\n  sync(): Promise<void>;\n}\n\ndeclare interface InternalStorageForm extends StorageForm {\n  binder: StorageBinder;\n}\n\nconst DEFAULT_INTERVAL = 700;\n\nexport function mixinStorageForm<T: HTMLFormElement>(c: Class<T>): Class<T & StorageForm> {\n  // $FlowFixMe Force cast to the returned type.\n  return class extends c {\n    initBinder: () => void;\n    binder: StorageBinder;\n\n    get autosync(): boolean { return this.hasAttribute(\"autosync\"); }\n    set autosync(b: boolean) { setAttrAsBoolean(this, \"autosync\", b); }\n\n    get autoload(): boolean { return this.hasAttribute(\"autoload\"); }\n    set autoload(b: boolean) { setAttrAsBoolean(this, \"autoload\", b); }\n\n    get interval(): number {\n      const n = parseInt(getAttr(this, \"interval\"));\n      return n > 300 ? n : DEFAULT_INTERVAL;\n    }\n    set interval(v: any) { this.setAttribute(\"interval\", v); }\n\n    get area(): ah.Area { return getAttr(this, \"area\"); }\n    set area(v: any) { this.setAttribute(\"area\", v); }\n\n    constructor() {\n      super();\n    }\n\n    createdCallback() {\n      this.binder = new StorageBinder(generateBindee(this));\n      this.binder.onChange = async (event) => {\n        dispatchEvent(this, `storage-form-${event.type}`, event);\n      };\n\n      this.binder.startAutoBinding();\n\n      this.addEventListener(\"submit\", (event) => {\n        event.preventDefault();\n        this.binder.submit({ force: true });\n      });\n\n      setObserver(this);\n    }\n\n    attachedCallback() {\n      this.binder.startAutoBinding();\n    }\n\n    static get observedAttributes() {\n      return [\n        \"autosync\",\n        \"autoload\",\n        \"area\",\n      ];\n    }\n\n    attributeChangedCallback(attrName: string) {\n      switch (attrName) {\n      case \"autosync\":\n      case \"autoload\":\n        this.binder.startAutoBinding();\n        break;\n      case \"area\":\n        this.initBinder();\n        this.binder.doAutoTask();\n        break;\n      }\n    }\n\n    initBinder() { this.binder.init(); }\n    load() { return this.binder.load({ force: true }); }\n    sync() { return this.binder.sync(); }\n  };\n}\n\nfunction generateBindee(self: InternalStorageForm): Bindee {\n  return {\n    getArea: () => self.area,\n    getInterval: () => self.interval,\n    isAutoSync: () => self.autosync,\n    isAutoLoad: () => self.autoload,\n    getNames: () => map(getStorageElements(self), e => (e: any).name),\n    getElements: () => getStorageElements(self),\n    getTarget: () => self,\n  };\n}\n\nfunction* getStorageElements(self: InternalStorageForm): Iterator<HTMLElement> {\n  for (const e of self.elements) {\n    if (e.area != null) continue; // filter out \"area-select\"\n    if (!e.name) continue;\n    yield e;\n  }\n}\n\nfunction dispatchEvent(self: HTMLElement, type: string, detail?: any): boolean {\n  return self.dispatchEvent(new CustomEvent(type, detail));\n}\n\nconst mixedForm = mixinStorageForm(HTMLFormElement);\nexport default class HTMLStorageFormElement extends mixedForm {\n  static get extends() { return \"form\"; }\n\n  static register() {\n    // Custom Element v1 seems not to works right to extend <form> in Google Chrome 55\n    // See http://stackoverflow.com/a/41458692/3864351\n    // Polyfill too: https://github.com/webcomponents/custom-elements/tree/master/src\n    // > To do: Implement built-in element extension (is=)\n    // customElements.define(\"storage-form\", StorageFormElement, { extends: \"form\" });\n    // window.StorageFormElement = StorageFormElement;\n\n    // Custom Element v0\n    document.registerElement(\"storage-form\", HTMLStorageFormElement);\n    document.registerElement(\"area-select\", AreaSelect);\n    document.registerElement(\"load-button\", LoadButton);\n  }\n}\n\nfunction setObserver(self: InternalStorageForm) {\n  const formControlObservers = new Map;\n\n  function observeFormControl(element: FormControlElement): void {\n    const o = new MutationObserver(() => self.binder.doAutoTask());\n    o.observe(element, { attributes: true, atributeFilter: [\"name\"] });\n    formControlObservers.set(element, o);\n  }\n\n  function disconnectFormControl(element: FormControlElement): void {\n    const o = formControlObservers.get(element);\n    if (o == null) return;\n    o.disconnect();\n    formControlObservers.delete(element);\n  }\n\n  // Observe added/removed form-controls\n  // Do NOT use MutationObserver. form controls are not always the DOM children of the form\n  // such as <input form=\"...\" ...>.\n  // And MutationObserver might be too heaby to observe all descendants of a body element.\n  observeFormControls(self, async ({ addedElements, removedElements }) => {\n    console.debug(\"detect added/removed form-controls\", self);\n    for (const e of addedElements) observeFormControl(e);\n    for (const e of removedElements) disconnectFormControl(e);\n    await self.binder.doAutoTask();\n  });\n}\n\ndeclare type FormControlChanges = {\n  addedElements: Set<FormControlElement>,\n  removedElements: Set<FormControlElement>,\n};\nfunction observeFormControls(self: InternalStorageForm, callback: (r: FormControlChanges) => Promise<void>) {\n  let elements = self.elements;\n  (async () => {\n    while (true) {\n      await waitAnimationFrame();\n      const newElements = self.elements;\n      if (isEqualsArray(elements, newElements)) continue;\n\n      const oldSet = new Set(elements);\n      const newSet = new Set(newElements);\n      const addedElements = utils.subtractSet(newSet, oldSet);\n      const removedElements = utils.subtractSet(oldSet, newSet);\n      elements = newElements;\n      await callback({ addedElements, removedElements });\n    }\n  })();\n}\n\nfunction isEqualsArray(a, b) {\n  if (a.length !== b.length) return false;\n  const len = a.length;\n  for (let i = 0; i < len; i++) if (a[i] !== b[i]) return false;\n  return true;\n}\n\nfunction getAttr(self: HTMLElement, name: string): string {\n  const v = self.getAttribute(name);\n  return v ? v : \"\";\n}\n\nfunction setAttrAsBoolean(self: HTMLElement, name: string, b: boolean) {\n  if (b) {\n    self.setAttribute(name, \"\");\n  } else {\n    self.removeAttribute(name);\n  }\n}\n\nfunction waitAnimationFrame() {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\nfunction* map(iter, mapper) {\n  for (const e of iter) yield mapper(e);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/storage-form.js"],"sourceRoot":""}